using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using MongoDB.Driver;

//------------------------------------------------------------------------------
// <auto-generated>
//     Controller: OrdersController
//     Purpose: Handles all order-related actions such as creation, updating, 
//     cancellation, and tracking the order's status.
//     Author: Katipearachchi M. E
//     Date: 06/10/2024
//     Description: This controller provides API endpoints for managing customer 
//     orders with role-based authorization.
// </auto-generated>
//------------------------------------------------------------------------------

[Route("api/[controller]")]
[ApiController]
public class OrdersController : ControllerBase
{
    private readonly MongoDbContext _context;

    // Constructor to initialize MongoDB context for database interactions
    public OrdersController(MongoDbContext context)
    {
        _context = context;
    }

    // Fetch all orders (Authorized for Admins and Vendors)
    [Authorize(Roles = "Administrator, Customer")]
    [HttpGet]
    public async Task<IActionResult> GetAllOrders()
    {
        // Retrieve all orders from the database
        var orders = await _context.Orders.Find(_ => true).ToListAsync(); 
        if (orders == null || !orders.Any())
        {
            return NotFound(new { Message = "No orders found." });
        }

        // Return fetched orders with a success message
        return Ok(new
        {
            Message = "Orders fetched successfully.",
            Orders = orders
        });
    }

    // Create a new customer order (Authorized for Vendors or Customers)
    [Authorize(Roles = "Vendor, Customer")]
    [HttpPost]
    public async Task<IActionResult> CreateOrder([FromBody] OrderRequest request)
    {
        // Validate the incoming request data
        if (!ModelState.IsValid)
        {
            return BadRequest(new
            {
                Message = "Invalid request data.",
                Errors = ModelState.Values.SelectMany(v => v.Errors.Select(e => e.ErrorMessage))
            });
        }

        // Create a new order using the request data
        var order = new Order
        {
            CustomerId = request.CustomerId,
            Products = request.Products.Select(p => new OrderProductRequest
            {
                ProductId = p.ProductId,
                VendorId = p.VendorId,
                Quantity = p.Quantity,
                Status = ProductStatus.Pending  // Set initial status to Pending
            }).ToList(),
            Status = OrderStatus.Processing,
            Notes = request.Notes,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
        };

        // Save the new order to the database
        await _context.Orders.InsertOneAsync(order);

        return Ok(new
        {
            Message = "Order created successfully.",
            Order = order
        });
    }

    // Update order details before the order is dispatched (Authorized for Vendor or Admin)
    [Authorize(Roles = "Vendor, Administrator")]
    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateOrder(string id, [FromBody] OrderUpdateRequest request)
    {
        // Find the order to update if it is still processing and not canceled
        var order = await _context.Orders.Find(o => o.Id == id && o.Status == OrderStatus.Processing && !o.IsCancelled).FirstOrDefaultAsync();
        if (order == null)
        {
            return BadRequest(new { Message = "Order cannot be updated after dispatch or it has been canceled." });
        }

        // Update the order's products and notes based on the request
        order.Products = request.Products;
        order.Notes = request.Notes;
        order.UpdatedAt = DateTime.UtcNow;  // Update the modification timestamp

        // Save the updated order to the database
        await _context.Orders.ReplaceOneAsync(o => o.Id == id, order);

        return Ok(new
        {
            Message = "Order updated successfully.",
            Order = order
        });
    }

    // Cancel an order before itâ€™s dispatched (Authorized for Vendor, Admin, or Customer)
    [Authorize(Roles = "Vendor, Administrator, Customer")]
    [HttpDelete("{id}")]
    public async Task<IActionResult> CancelOrder(string id)
    {
        // Find the order to cancel if it is still processing and not canceled
        var order = await _context.Orders.Find(o => o.Id == id && o.Status == OrderStatus.Processing && !o.IsCancelled).FirstOrDefaultAsync();
        if (order == null)
        {
            return BadRequest(new { Message = "Order cannot be updated after dispatch or it has been canceled." });
        }

        // Mark the order as canceled
        order.Status = OrderStatus.Cancelled;
        order.IsCancelled = true;
        order.UpdatedAt = DateTime.UtcNow;

        // Save the changes to the database
        await _context.Orders.ReplaceOneAsync(o => o.Id == id, order);

        return Ok(new { Message = "Order canceled successfully." });
    }

    // Get the status of a specific order (Authorized for Vendor, Admin, Customer, or CSR)
    [Authorize(Roles = "Vendor, Administrator, Customer, CSR")]
    [HttpGet("{id}/status")]
    public async Task<IActionResult> GetOrderStatus(string id)
    {
        // Find the order by its ID
        var order = await _context.Orders.Find(o => o.Id == id).FirstOrDefaultAsync();
        if (order == null)
        {
            return BadRequest(new { Message = "Order not found." });
        }

        // Return the current status of the order
        return Ok(new { Status = order.Status });
    }

    // Mark the order as shipped (Authorized for Vendor or Admin)
    [Authorize(Roles = "Vendor, Administrator")]
    [HttpPut("{id}/ship")]
    public async Task<IActionResult> MarkOrderAsShipped(string id)
    {
        // Find the order to mark as shipped if it is still processing
        var order = await _context.Orders.Find(o => o.Id == id && o.Status == OrderStatus.Processing).FirstOrDefaultAsync();
        if (order == null)
        {
            return BadRequest(new { Message = "Order cannot be marked as shipped. It may be canceled or already shipped/delivered." });
        }

        // Update the order status to shipped and record the dispatch time
        order.Status = OrderStatus.Shipped;
        order.DispatchedAt = DateTime.UtcNow;
        order.UpdatedAt = DateTime.UtcNow;

        // Save the updated order to the database
        await _context.Orders.ReplaceOneAsync(o => o.Id == id, order);

        return Ok(new { Message = "Order marked as shipped." });
    }

    // Mark the order as paid (Authorized for Customers)
    [Authorize(Roles = "Customer")]
    [HttpPut("{id}/payment")]
    public async Task<IActionResult> MarkOrderAsPayed(string id)
    {
        // Find the order to mark as paid
        var order = await _context.Orders.Find(o => o.Id == id).FirstOrDefaultAsync();
        if (order == null)
        {
            return BadRequest(new { Message = "Order cannot be marked as paid. It may be canceled or already shipped/delivered." });
        }

        // Mark the order as paid
        order.IsPayed = true;
        order.UpdatedAt = DateTime.UtcNow;

        // Save the changes to the database
        await _context.Orders.ReplaceOneAsync(o => o.Id == id, order);

        return Ok(new { Message = "Order marked as paid." });
    }
}
